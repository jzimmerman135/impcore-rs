;;;;;;;;;;;;;;;;;;; CS 105 IMPCORE ASSIGNMENT ;;;;;;;;;;;;;;;

;; Your Name: Jacob Zimmerman


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;  Problem 1


;; (double-digit n) repeats every digit in a number, e.g. 4123 becomes 44112233
;;      returns an error if n is greater than 19999

;; laws:
;;   (double-digit d) == ((* 10 d) + d)
;;   (double-digit (+ (* m 10) d)) == (+ (double-digit d)
;;                                       (* (double-digit m) 100))
;;   (double-digit (+ 20000 m)) == (error)

(define double-digit (n)
    (if (< n 20000)
        (if (< n 10)
            (+ (* n 10) n)
            (+ (double-digit (mod n 10))
               (* (double-digit (/ n 10)) 100)))
        (error)))

        (check-assert (= (double-digit 0) 00))
        (check-assert (= (double-digit 1) 11))
        (check-assert (= (double-digit 9) 99))
        (check-assert (= (double-digit 10) 1100))
        (check-assert (= (double-digit 12345) 1122334455))
        (check-assert (= (double-digit 19999) 1199999999))
        (check-assert (= (double-digit 0000000) 0))
        (check-assert (= (double-digit 1) 0))
        (check-expect (double-digit 1) 0)
        (check-error (double-digit 20000))
        (check-error (double-digit 20001))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;  Problem 2


;; (population-count n) returns the total number of 1 bits in the binary
;;      representation of n

;; laws:
;;   (population-count 0) == 0
;;   (population-count (+ (* m 2) b)) == (+ b (population-count m))

(define population-count (n)
    (if (= n 0)
        0
        (+ (mod n 2) (population-count (/ n 2)))))

        (check-assert (= (population-count 0) 0))
        (check-assert (= (population-count 1) 1))
        (check-assert (= (population-count 2) 1))
        (check-assert (= (population-count 3) 2))
        (check-assert (= (population-count 3) 2))
        (check-assert (= (population-count 143) 5))
        (check-assert (= (population-count 255) 8))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;  Problem 3


;; (binary n) returns a decimal number that looks like the binary
;;      representation of n, e.g. 12 becomes 1100

;; laws:
;;   (binary 0) == 0
;;   (binary (+ (* m 2) b) == (+ (* (binary m) 10) b)

(define binary (n)
    (if (= n 0)
        n
        (+ (* (binary (/ n 2)) 10)
           (mod n 2))))

        (check-expect (binary 0) 0)
        (check-expect (binary 1) 1)
        (check-expect (binary 12) 1100)
        (check-expect (binary 255) 11111111)
        (check-expect (binary -5) -101)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;  Problem 4


;; (sigma m n) returns sum of all numbers from m to n inclusively, assuming
;;       m <= n

;; laws:
;;   (sigma m n) == 0, where m > n
;;   (sigma (- m 1) n) == (+ m (sigma m n)), where n <= m

(define sigma (m n)
    (if (> m n)
        0
        (+ m (sigma (+ m 1) n))))

        (check-expect (sigma 0 0) 0)
        (check-expect (sigma 1 1) 1)
        (check-expect (sigma 1 2) 3)
        (check-expect (sigma 4 4) 4)
        (check-expect (sigma 0 10) (sigma 1 10))
        (check-expect (sigma 10 20) 165)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;  Problem 5

;; (has-divisor? n d) returns true iff n has a divisor between d,
;;    and half of n.

;; laws:
;;   (has-divisor? m (+ (/ m 2) m')) == false
;;   (has-divisor? m (m' + 1)) == (|| (= 0 (mod m m'))
;;                                    (has-divisor? m m'))

(define has-divisor? (n d)
    (if (> d (/ n 2))
        0
        (if (= 0 (mod n d))
            1
            (has-divisor? n (+ d 1)))))


;; (prime? n) returns true iff n is a prime number

;; laws:
;;   (prime? m, where m < 2) == false
;;   (prime? m) == (has-divisor? m)

(define prime? (n)
    (if (< n 2)
        0
        (not (has-divisor? n 2))))

        (check-assert (not (prime? 0)))
        (check-assert (not (prime? 1)))
        (check-assert (not (prime? 4)))
        (check-assert (not (prime? 9)))
        (check-assert (not (prime? 1000)))
        (check-assert (prime? 2))
        (check-assert (prime? 3))
        (check-assert (prime? 7))
        (check-assert (prime? 523))
        (check-assert (prime? 1000125207))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;  Problem 6

;; (next-prime p n) calculates nth next prime number from some number p

;; laws:
;;   (next-prime p 1) == p
;;   (next-prime m' m) == (next-prime (+ m' 1) m)
;;   (next-prime p (+ m 1)) == (next-prime (+ p 1) m)

(define next-prime (p n)
    (if (prime? p)
        (if (= n 1)
            p
            (next-prime (+ p 1)(- n 1)))
        (next-prime (+ p 1) n)))


;; (nthprime n) calculates the nth prime number assuming 2 is the 1st. Fails
;;   on input less than 1.

;; laws:
;;   (nthprime 1) == (next-prime 2 n)

(define nthprime (n)
    (next-prime 2 n))

        (check-expect (nthprime 1) 2)
        (check-expect (nthprime 2) 3)
        (check-expect (nthprime 3) 5)
        (check-expect (nthprime 4) 7)
        (check-expect (nthprime 5) 11)
        (check-expect (nthprime 16) 53)
    
(define badFunc (n) (* n 10))
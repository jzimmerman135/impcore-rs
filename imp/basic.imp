(define add-ten (x) (+ 10 x))
(define locals (n x)
    (begin (if (> n 0)
               (set n 14)
               (set n (- 0 13)))
            (+ n x)))
(define set-global-with-loop (x) 
    (+ x
        (while (< (- t 1) x)
                (set t (+ t 1)))))
(define sum-arr (i sum) 
    (if (= i 0)
        sum
        (sum-arr (-- i) (+ sum arr[i]))))
(define array-xor-swap (A[] i j)
    (begin 
        (set A[i] (^ A[i] A[j]))
        (set A[j] (^ A[j] A[i]))
        (set A[i] (^ A[i] A[j]))
        0))

;; 0 - 3 tests variables and top level expressions
(+ 0 0)
1
(val n 2)
(add-ten (/ 70 -10))

;; 4 - 6 tests local scope precedence
(locals 8 -10)
(locals -8 18)
(+ n 4)

;; 7 - 12 tests multiple globals and setting them various contexts
(val t (set n 7))
(set-global-with-loop 8)
t
(+ n 3)
(val t 11)
(+ t 1)

;; 13 - 20 working with global arrays
(val arr[] 13)
(set arr[3] 14)
(set arr[9] 15)
(+ 2 arr[3])
(+ 2 arr[9])
(set arr[3] 18)
(+ arr[3] 1)
(- (sum-arr 12 0) 13)

;; 21 - 26 passing global arrays
(val swaparr[] 21)
(set swaparr[0] 22)
(set swaparr[6] 23)
(+ 24 (array-xor-swap swaparr[] 0 6))
(+ 3 swaparr[6])
(+ 3 swaparr[0])


;; 27 - 28 binary arithmetic
(val bits 0x1b)
(| (& bits 0x18) 4)
